LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
USE ieee.std_logic_unsigned.all;
USE work.aux_package.all;

ENTITY PWM IS
  PORT (
    BTCCR0 : IN STD_LOGIC_vector (31 DOWNTO 0);
	BTCCR1 : IN STD_LOGIC_vector (31 DOWNTO 0);
    BTOUTEN, RST, CLK: in STD_LOGIC;
    BTOUTMD : IN   STD_LOGIC;
    PWM_OUT : out STD_LOGIC;
	BTSSEL  : IN STD_LOGIC_vector (1 DOWNTO 0);
	BTIPx   :  IN   STD_LOGIC;
	Set_BTIFG: out STD_LOGIC;
  );
END ENTITY PWM;

ARCHITECTURE PWM_MODULE OF PWM IS
    subtype vector IS STD_LOGIC_vector(31 DOWNTO 0);   
    SIGNAL BTCL0: vector;
    SIGNAL BTCL1: vector;
    SIGNAL BTCNT: std_logic_vector(31 downto 0);
    SIGNAL PWM_OUT_REG: std_logic := '0';
	SIGNAL COUNT_DIVIDER : STD_LOGIC_vector(3 DOWNTO 0); 
	SIGNAL COUNT_LIMIT : STD_LOGIC_vector(3 DOWNTO 0);  
	signal CHOSEN_CLK  : STD_LOGIC:= '0';
	signal bt_counter  : std_logic_vector(4 downto 0);
	signal bt_counter_limit  : std_logic_vector(4 downto 0);
BEGIN
    BTCL0 <= BTCCR0 WHEN BTOUTEN = '1' else (others => '0');
    BTCL1 <= BTCCR1 WHEN BTOUTEN = '1' else (others => '0');
	
	COUNT_LIMIT <= "0001" when BTSSEL = "01" else "0011" WHEN BTSSEL = "10" ELSE "0111" WHEN BTSSEL = "11";
	bt_counter_limit <= "00001" when BTIPx = "000" else "00100" when BTIPx = "001" else "01000" when BTIPx = "010" else "01100" when BTIPx = "011"
						else "10000" when BTIPx = "100" else "10100" when BTIPx = "101" else "11000" when BTIPx = "110"
						else "11010" when BTIPx = "111" ;
	
    process(CLK, RST)
    begin
		if BTSSEL = '00' then
			CHOSEN_CLK <= clk;
		else
			if  COUNT_DIVIDER = COUNT_LIMIT then
				COUNT_DIVIDER <= x"0";
				CHOSEN_CLK <= '1';
			ELSE
				CHOSEN_CLK <= '0';
				COUNT_DIVIDER <= COUNT_DIVIDER + 1;
			end if;
		end if;

		if rising_edge(CHOSEN_CLK) then
			if bt_counter = bt_counter_limit then
				Set_BTIFG <= '1';
				bt_counter <= "00000"
			else
				bt_counter <= bt_counter + 1;
				Set_BTIFG <= '0';
			end if;
		end if;

        if RST = '1' then
            BTCNT <= (others => '0');
            PWM_OUT_REG <= '0';
        elsif rising_edge(CHOSEN_CLK) then	
			if BTCNT >= BTCL0 then --making sure that the counter is from 0 to BTCL0
				BTCNT <= (others => '0');
			else
				BTCNT <= BTCNT + 1;
			end if;
			
			
            if BTOUTEN = '1' then
				if BTOUTMD = '0' then
					if (unsigned (BTCNT) >= unsigned (BTCL1)) and (unsigned (BTCNT) < unsigned (BTCL0)) then -- 
						PWM_OUT_REG <= '1';
					else
						PWM_OUT_REG <= '0';
					end if;
				else --BTOUTMD = '1'
					if (unsigned (BTCNT) < unsigned (BTCL1)) then
						PWM_OUT_REG <= '1';
					else
						PWM_OUT_REG <= '0';
					end if;
				end if;
			else
				PWM_OUT_REG <= '0';
            end if;
        end if;
    end process;

    PWM_OUT <= PWM_OUT_REG;

END ARCHITECTURE PWM_MODULE;

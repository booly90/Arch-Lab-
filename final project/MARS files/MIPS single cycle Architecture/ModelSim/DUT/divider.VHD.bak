library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity Divider is
    Port (
        dividend : in std_logic_vector(31 downto 0);
        divisor  : in std_logic_vector(31 downto 0);
        divclk   : in std_logic;
        rst      : in std_logic;
        ena      : in std_logic;
        divif    : in std_logic;
        result   : out std_logic_vector(31 downto 0);
        remainder : out std_logic_vector(31 downto 0)
    );
end Divider;

architecture Behavioral of Divider is
    signal temp_dividend : std_logic_vector(31 downto 0);
    signal temp_result : std_logic_vector(31 downto 0);
    signal temp_remainder : std_logic_vector(31 downto 0);
    signal temp_divisor : std_logic_vector(31 downto 0);
    signal count         : integer := 0;
    signal busy          : std_logic := '0';
	signal debug          : std_logic := '0';
	signal temp_dividend_temp   : std_logic_vector(32 downto 0);

begin
process(divclk, rst)
    -- Declare necessary signals outside the process
    signal temp_sub : std_logic_vector(31 downto 0);  -- For holding subtraction result
begin
    if rst = '1' then
        temp_dividend <= (others => '0');
        temp_result <= (others => '0');
        temp_remainder <= (others => '0');
        count         <= 0;
        busy          <= '0';
    elsif rising_edge(divclk) then
        if ena = '1' and busy = '0' then
            if divif = '1' then
                -- Initialize for division
                temp_dividend <= (others => '0'); 
                temp_divisor  <= divisor;
                temp_remainder <= (others => '0');
                temp_result  <= (others => '0');
                count         <= 31;  -- Start count from 31 (highest bit index)
                busy          <= '1';
            end if;
        elsif busy = '1' then
            if count >= 0 then
                debug <= dividend(count);
                
                -- Perform subtraction if needed and store in temp_sub
                if unsigned(temp_dividend) >= unsigned(temp_divisor) then
                    temp_sub <= std_logic_vector(unsigned(temp_dividend) - unsigned(temp_divisor));
                    temp_dividend <= temp_sub(30 downto 0) & dividend(count);
                    temp_result <= temp_result(30 downto 0) & '1';
                else
                    temp_result <= temp_result(30 downto 0) & '0';
                    temp_dividend <= temp_dividend(30 downto 0) & dividend(count);
                end if;

                count <= count - 1;
            else
                busy <= '0';
                temp_remainder <= temp_dividend;
            end if;
        end if;
    end if;
end process;

-- Output assignments

    result <= temp_result;
    remainder <= temp_remainder;
end Behavioral;
